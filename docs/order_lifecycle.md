# qtrader Order Lifecycle (Parent / Child Enhanced)

This document updates the original walkthrough to reflect a clean execution hierarchy:

```
eng(Intent)
   → net(Aggregate → Required Delta)
      → om(ParentOrder → Order → ChildOrder)
```

The goal is to separate **intent**, **necessity**, and **execution**, while keeping the OMS replayable, broker-agnostic, and easy to reason about.

---

## 1. Intent Layer (eng.q)

Intent expresses *desired position*, not trades.

```
Intent:
time,p
sym,s
strat,s
tgtpos,j
urgency,f
info,*
```

Rules:
- Per-strategy
- Stateless
- No prices
- No execution logic

Example:

```
09:30:01.000  AAPL  strat1  +100  0.3
09:30:01.010  AAPL  strat2  +200  0.8
```

---

## 2. Netting Layer (net.q)

Net aggregates intents and compares them to actual position.

```
AggTarget = sum(tgtpos by sym)
ReqQty    = AggTarget - ActualPosition
```

Contract to OMS:

```
Req:
sym:  AAPL
qty:  +300
```

Net never specifies:
- prices
- algos
- order types

It only specifies *what must change*.

---

## 3. ParentOrder (Execution Intent)

**Owner:** om.q

A ParentOrder represents the OMS’s commitment to satisfy a net requirement.

```
ParentOrder:
parentid,j
sym,s
side,h
tgtqty,j
filled,j
algo,s
urgency,f
status,s
created,p
deadline,p
```

Example:

```
parentid: 5001
sym: AAPL
side: BUY
tgtqty: 300
filled: 0
algo: twap
urgency: 0.63
status: WORKING
```

Properties:
- One ParentOrder per net request
- Stable across cancel/replace
- Never sent to broker

---

## 4. Order (Execution Attempts)

Orders represent logical execution attempts generated by the OMS.

```
Order:
orderid,j
parentid,j
sym,s
side,h
price,f
size,j
filled,j
pending,j
status,s
tsnew,p
tsupdate,p
note,*
```

One ParentOrder → many Orders over time.

Orders are:
- cancellable
- replaceable
- repriced
- partially filled

---

## 5. ChildOrder (Broker-Facing)

ChildOrders adapt Orders to broker-specific requirements.

```
ChildOrder:
childid,j
orderid,j
brokerid,s
venue,s
sym,s
side,h
price,f
size,j
status,s
sent,p
lastupdate,p
```

Responsibilities:
- broker IDs
- FIX / API parameters
- venue routing

Only ChildOrders are visible externally.

---

## 6. Execution Feedback Loop

```
Broker Fill
 → ChildOrder update
   → Order update
     → ParentOrder progress
       → Position update
         → net recalculates Req
```

OMS is a deterministic state machine driven by fills.

---

## 7. Status Semantics

### Order Status
- NEW
- PARTIAL
- FILLED
- CANCELLED
- REJECTED

### ParentOrder Status
- WORKING
- DONE
- CANCELLED
- FAILED

ParentOrder status is derived from child progress.

---

## 8. Design Invariants

- ParentOrder answers: *What am I trying to do?*
- Order answers: *What did I try?*
- ChildOrder answers: *What did the broker see?*

Net never sees Orders.
Broker never sees ParentOrders.
Strategies never see execution.

---

## 9. Minimal Viable OMS Tables

Required:
- ParentOrder
- Order
- Fill
- Position

Optional:
- ChildOrder (multi-broker)
- ExecState (algo runtime)
- Limits / Breaches

---

## 10. Summary

This structure cleanly separates concerns:

| Layer | Responsibility |
|-----|----------------|
| eng | Desired position |
| net | Required delta |
| ParentOrder | Execution intent |
| Order | Execution attempts |
| ChildOrder | Broker adaptation |
| Broker | Marketplace |

If you can replay ParentOrders and Fills to deterministically reconstruct state, your OMS is correct.
